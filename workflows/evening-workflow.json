{
  "name": "evening routine v2.2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "tennis-results",
        "responseMode": "lastNode",
        "responseData": "allEntries",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -3216,
        224
      ],
      "id": "c17c61f9-a736-45f7-a0e7-14347cd53176",
      "name": "Webhook",
      "webhookId": "de9b81b0-c4b6-44be-bb89-39152b9f78c1"
    },
    {
      "parameters": {
        "jsCode": "  // Extract matches array from webhook body\n  const webhookData = $input.first().json;\n  const matches = webhookData.body;\n\n  // Helper function to escape single quotes for SQL\n  function escapeSql(str) {\n    if (!str) return '';\n    return str.toString().replace(/'/g, \"''\");\n  }\n\n  // Return each match with SQL-safe values\n  return matches.map(match => ({\n    json: {\n      tournament: escapeSql(match.tournament),\n      player1: escapeSql(match.player1),\n      player2: escapeSql(match.player2),\n      winner: escapeSql(match.winner),\n      score: match.score,\n      odds1: match.odds1,\n      odds2: match.odds2,\n      surface: match.surface,\n      country: match.country,\n      player1_nationality: match.nationality1,\n      player2_nationality: match.nationality2,\n      match_date: match.match_date || new Date().toISOString().split('T')[0]\n    }\n  }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3008,
        224
      ],
      "id": "ea040a58-d45e-491f-8cdb-b10e26455fdb",
      "name": "Extract mathces"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -2800,
        224
      ],
      "id": "cc8a764f-ccaf-4c2a-afa6-2c20e5a1c2b1",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "  SELECT prediction_id, predicted_winner, confidence_score\n  FROM predictions\n  WHERE player1 = '{{ $json.player1 }}'\n    AND player2 = '{{ $json.player2 }}'\n    AND tournament = '{{ $json.tournament }}'\n  LIMIT 1;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2592,
        288
      ],
      "id": "64d80b14-294c-4676-9b81-345b1a18d75c",
      "name": "Find Matching Prediction",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "  UPDATE predictions\n  SET\n    actual_winner = '{{ $('Loop Over Items').item.json.winner }}',\n    prediction_correct = (predicted_winner = '{{ $('Loop Over Items').item.json.winner }}')\n  WHERE prediction_id = {{ $(\"Find Matching Prediction\").item.json.prediction_id }}\n  RETURNING\n    prediction_id,\n    predicted_winner,\n    actual_winner,\n    prediction_correct,\n    confidence_score,\n    tournament,\n    surface,\n    player1,\n    player2,\n    odds_player1,\n    odds_player2,\n    '{{ $('Loop Over Items').item.json.match_date }}'::date as match_date;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1920,
        288
      ],
      "id": "c7cee310-5acb-4691-8da1-35cef2518e4c",
      "name": "Update Prediction",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "  // Get all updated predictions from the loop\n  const results = $(\"Loop Over Items\").all();\n\n  // Calculate statistics\n  const total = results.length;\n  const correct = results.filter(r => r.json.prediction_correct === true).length;\n  const incorrect = total - correct;\n  const accuracy = ((correct / total) * 100).toFixed(2);\n\n  // Calculate average confidence\n  const avgConfidence = Math.round(\n    results.reduce((sum, r) => sum + r.json.confidence_score, 0) / total\n  );\n\n  // Group by confidence bucket\n  const highConf = results.filter(r => r.json.confidence_score >= 60);\n  const mediumConf = results.filter(r => r.json.confidence_score >= 50 && r.json.confidence_score < 60);\n  const lowConf = results.filter(r => r.json.confidence_score < 50);\n\n  const stats = {\n    date: new Date().toISOString().split('T')[0],\n    total_predictions: total,\n    correct_predictions: correct,\n    incorrect_predictions: incorrect,\n    accuracy_percentage: parseFloat(accuracy),\n    average_confidence: avgConfidence,\n\n    high_confidence: {\n      total: highConf.length,\n      correct: highConf.filter(r => r.json.prediction_correct).length,\n      accuracy: highConf.length > 0 ?\n        ((highConf.filter(r => r.json.prediction_correct).length / highConf.length) * 100).toFixed(2) : 0\n    },\n\n    medium_confidence: {\n      total: mediumConf.length,\n      correct: mediumConf.filter(r => r.json.prediction_correct).length,\n      accuracy: mediumConf.length > 0 ?\n        ((mediumConf.filter(r => r.json.prediction_correct).length / mediumConf.length) * 100).toFixed(2) : 0\n    },\n\n    low_confidence: {\n      total: lowConf.length,\n      correct: lowConf.filter(r => r.json.prediction_correct).length,\n      accuracy: lowConf.length > 0 ?\n        ((lowConf.filter(r => r.json.prediction_correct).length / lowConf.length) * 100).toFixed(2) : 0\n    }\n  };\n\n  return { json: stats };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        128
      ],
      "id": "a4a89b88-ef62-4429-8874-e3a694de643d",
      "name": "Calculate Daily Stats"
    },
    {
      "parameters": {
        "jsCode": "const stats = $('Calculate Daily Stats').first().json;\nconst metadata = $('Update System Metadata').first().json;\nconst analysis = $('Extract LLM Response').first().json;\n\nconst message = `ðŸ“Š DAILY RESULTS PROCESSED\nðŸ“… ${stats.date}\n\nâœ… ACCURACY SUMMARY:\nâ€¢ Total predictions: ${stats.total_predictions}\nâ€¢ Correct: ${stats.correct_predictions}\nâ€¢ Incorrect: ${stats.incorrect_predictions}\nâ€¢ Overall accuracy: ${stats.accuracy_percentage}%\n\nðŸ“ˆ BY CONFIDENCE LEVEL:\nðŸ”´ High (60%+): ${stats.high_confidence.correct}/${stats.high_confidence.total} (${stats.high_confidence.accuracy}%)\nðŸŸ¡ Medium (50-59%): ${stats.medium_confidence.correct}/${stats.medium_confidence.total} (${stats.medium_confidence.accuracy}%)\nðŸŸ¢ Low (<50%): ${stats.low_confidence.correct}/${stats.low_confidence.total} (${stats.low_confidence.accuracy}%)\n\nðŸ’¡ Average confidence: ${stats.average_confidence}%\n\nðŸŽ“ LEARNING ANALYSIS:\n${analysis.summary}\n\nðŸ“ˆ SYSTEM STATUS:\nâ€¢ Day: ${metadata.days_operated}\nâ€¢ Phase: ${metadata.learning_phase}\nâ€¢ Total accuracy: ${metadata.overall_accuracy}%\nâ€¢ Pinecone records: ${metadata.pinecone_record_count}\n\nðŸ” Top Action Items:\n${analysis.action_items.slice(0, 3).map((item, i) => `${i+1}. ${item}`).join('\\n')}\n\nðŸŽ¯ All predictions updated in database!`;\n\nreturn {\n  json: {\n    message: message,\n    chat_id: '7142286210',\n    parse_mode: ''\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        144
      ],
      "id": "98712aad-a7d0-4c51-accb-5a96e0c266e6",
      "name": "Format Telegram Message"
    },
    {
      "parameters": {
        "chatId": "7142286210",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "appendAttribution": false
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1312,
        144
      ],
      "id": "78134ce3-d06b-4ec2-8df3-0410e4cd2537",
      "name": "Send a text message",
      "webhookId": "17ffad1b-5c9f-4965-b87a-67a96963a037",
      "credentials": {
        "telegramApi": {
          "id": "gPRsbNhjNn4pXQAB",
          "name": "Telegram account stocker"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "  // Get all Pinecone records from previous node\n  const allRecords = $input.all();\n\n  const BATCH_SIZE = 90; // Pinecone limit is 96, use 90 to be safe\n\n  // Split records into batches of 90\n  const batches = [];\n  for (let i = 0; i < allRecords.length; i += BATCH_SIZE) {\n    const batch = allRecords.slice(i, i + BATCH_SIZE);\n\n    // Convert batch to NDJSON format\n    const ndjson = batch.map(item => {\n      const record = item.json;\n      return {\n        _id: record.id,\n        match_context: record.match_context,\n        tournament: record.tournament,\n        surface: record.surface,\n        player1: record.player1,\n        player2: record.player2,\n        winner: record.winner,\n        predicted_winner: record.predicted_winner,\n        prediction_correct: record.prediction_correct,\n        odds_winner: record.odds_winner,\n        match_date: record.match_date\n      };\n    })\n    .map(record => JSON.stringify(record))\n    .join('\\n');\n\n    batches.push({\n      json: {\n        ndjson_data: ndjson,\n        batch_number: batches.length + 1,\n        record_count: batch.length,\n        total_records: allRecords.length\n      }\n    });\n  }\n\n  console.log(`Split ${allRecords.length} records into ${batches.length} batches`);\n\n  // Return all batches as separate items\n  return batches;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1568,
        128
      ],
      "id": "d5beb645-9861-4926-9d32-5a7a75466e81",
      "name": "Prepare Pinecone Batch"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://tennis-match-embeddings-bjs37qr.svc.aped-4627-b74a.pinecone.io/records/namespaces/production/upsert",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "pineconeApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/x-ndjson"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ $json.ndjson_data }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        128
      ],
      "id": "6b1ea2dd-7eac-4be1-8c75-4665889f14db",
      "name": "Upload to Pinecone",
      "retryOnFail": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "nxpZYiVvscfFFQIe",
          "name": "Header Auth openrouter"
        },
        "pineconeApi": {
          "id": "zDSlU5rks5rQ8PdT",
          "name": "PineconeApi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "  // Get ALL updated predictions from the loop\n  const allResults = $input.all();\n\n  console.log(`Processing ${allResults.length} records for Pinecone`);\n\n  // Build Pinecone record for each match\n  const pineconeRecords = allResults.map(item => {\n    const match = item.json;\n\n    // Use match_date from the match data (with fallback to current date)\n    const matchDate = match.match_date || new Date().toISOString().split('T')[0];\n\n    // Build match context text for embedding\n    const matchContext = `\nMatch: ${match.player1} vs ${match.player2}\nTournament: ${match.tournament}\nSurface: ${match.surface}\nOdds: ${match.player1} ${match.odds_player1} | ${match.player2} ${match.odds_player2}\nPredicted Winner: ${match.predicted_winner} (${match.confidence_score}% confidence)\nActual Winner: ${match.actual_winner}\nResult: ${match.prediction_correct ? 'CORRECT' : 'INCORRECT'}\n    `.trim();\n\n    return {\n      json: {\n        id: `${match.tournament}_${match.player1}_${match.player2}_${matchDate}`.replace(/[^a-zA-Z0-9_-]/g, '_'),\n        match_context: matchContext,\n        tournament: match.tournament,\n        surface: match.surface,\n        player1: match.player1,\n        player2: match.player2,\n        winner: match.actual_winner,\n        predicted_winner: match.predicted_winner,\n        prediction_correct: match.prediction_correct,\n        odds_winner: match.actual_winner === match.player1 ? match.odds_player1 : match.odds_player2,\n        match_date: matchDate\n      }\n    };\n  });\n\n  // Return all records\n  return pineconeRecords;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2384,
        128
      ],
      "id": "678b4371-dddc-45dd-876f-d2b928d8b1a9",
      "name": "Build All Pinecone Records"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Fixed: Simple match insertion with nationality updates (correct field names)\nINSERT INTO matches (\n  match_unique_id,\n  tournament,\n  country,\n  surface,\n  player1,\n  player1_nationality,\n  player2,\n  player2_nationality,\n  odds_player1,\n  odds_player2,\n  winner,\n  loser,\n  score,\n  match_date,\n  is_upset,\n  odds_winner,\n  odds_loser,\n  implied_prob_player1,\n  implied_prob_player2,\n  favorite,\n  favorite_won\n)\nVALUES (\n  '{{ $('Loop Over Items').item.json.tournament }}_{{ $('Loop Over Items').item.json.player1 }}_{{ $('Loop Over Items').item.json.player2 }}_{{ $('Loop Over Items').item.json.match_date }}',\n  '{{ $('Loop Over Items').item.json.tournament }}',\n  '{{ $('Loop Over Items').item.json.country }}',\n  '{{ $('Loop Over Items').item.json.surface }}',\n  '{{ $('Loop Over Items').item.json.player1 }}',\n  '{{ $('Loop Over Items').item.json.nationality1 }}',\n  '{{ $('Loop Over Items').item.json.player2 }}',\n  '{{ $('Loop Over Items').item.json.nationality2 }}',\n  {{ $('Loop Over Items').item.json.odds1 }},\n  {{ $('Loop Over Items').item.json.odds2 }},\n  '{{ $('Loop Over Items').item.json.winner }}',\n  (CASE\n    WHEN '{{ $('Loop Over Items').item.json.winner }}' = '{{ $('Loop Over Items').item.json.player1 }}'\n      THEN '{{ $('Loop Over Items').item.json.player2 }}'\n    ELSE '{{ $('Loop Over Items').item.json.player1 }}'\n  END),\n  '{{ $('Loop Over Items').item.json.score }}',\n  '{{ $('Loop Over Items').item.json.match_date }}'::date,\n  (CASE\n    WHEN {{ $('Loop Over Items').item.json.odds1 }} < {{ $('Loop Over Items').item.json.odds2 }}\n      THEN '{{ $('Loop Over Items').item.json.winner }}' != '{{ $('Loop Over Items').item.json.player1 }}'\n    ELSE '{{ $('Loop Over Items').item.json.winner }}' != '{{ $('Loop Over Items').item.json.player2 }}'\n  END),\n  (CASE\n    WHEN '{{ $('Loop Over Items').item.json.winner }}' = '{{ $('Loop Over Items').item.json.player1 }}'\n      THEN {{ $('Loop Over Items').item.json.odds1 }}\n    ELSE {{ $('Loop Over Items').item.json.odds2 }}\n  END),\n  (CASE\n    WHEN '{{ $('Loop Over Items').item.json.winner }}' = '{{ $('Loop Over Items').item.json.player1 }}'\n      THEN {{ $('Loop Over Items').item.json.odds2 }}\n    ELSE {{ $('Loop Over Items').item.json.odds1 }}\n  END),\n  ROUND((1.0 / {{ $('Loop Over Items').item.json.odds1 }}) * 100, 2),\n  ROUND((1.0 / {{ $('Loop Over Items').item.json.odds2 }}) * 100, 2),\n  (CASE\n    WHEN {{ $('Loop Over Items').item.json.odds1 }} < {{ $('Loop Over Items').item.json.odds2 }}\n      THEN '{{ $('Loop Over Items').item.json.player1 }}'\n    ELSE '{{ $('Loop Over Items').item.json.player2 }}'\n  END),\n  (CASE\n    WHEN {{ $('Loop Over Items').item.json.odds1 }} < {{ $('Loop Over Items').item.json.odds2 }}\n      THEN '{{ $('Loop Over Items').item.json.winner }}' = '{{ $('Loop Over Items').item.json.player1 }}'\n    ELSE '{{ $('Loop Over Items').item.json.winner }}' = '{{ $('Loop Over Items').item.json.player2 }}'\n  END)\n)\nON CONFLICT (match_unique_id) DO UPDATE SET\n  winner = EXCLUDED.winner,\n  loser = EXCLUDED.loser,\n  score = EXCLUDED.score,\n  is_upset = EXCLUDED.is_upset,\n  odds_winner = EXCLUDED.odds_winner,\n  odds_loser = EXCLUDED.odds_loser,\n  implied_prob_player1 = EXCLUDED.implied_prob_player1,\n  implied_prob_player2 = EXCLUDED.implied_prob_player2,\n  favorite = EXCLUDED.favorite,\n  favorite_won = EXCLUDED.favorite_won;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1760,
        288
      ],
      "id": "8b330d01-68d6-4c7e-9283-297ff46586f1",
      "name": "Insert Match Into Database",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update player nationalities from recently inserted matches\nUPDATE players \nSET nationality = match_data.nationality\nFROM (\n  SELECT \n    player1 as player_name, \n    player1_nationality as nationality\n  FROM matches \n  WHERE match_date = CURRENT_DATE - INTERVAL '1 day'\n    AND player1_nationality IS NOT NULL \n    AND player1_nationality != ''\n  \n  UNION ALL\n  \n  SELECT \n    player2 as player_name, \n    player2_nationality as nationality\n  FROM matches \n  WHERE match_date = CURRENT_DATE - INTERVAL '1 day'\n    AND player2_nationality IS NOT NULL \n    AND player2_nationality != ''\n) match_data\nWHERE players.player_name = match_data.player_name\n  AND (players.nationality IS NULL OR players.nationality = '' OR players.nationality != match_data.nationality);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -800,
        288
      ],
      "id": "update-player-nationalities",
      "name": "Update Player Nationalities",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH stats AS (\n  SELECT\n    COUNT(*) as total_preds,\n    SUM(CASE WHEN prediction_correct = true THEN 1 ELSE 0 END) as correct_preds,\n    SUM(CASE WHEN prediction_correct = false THEN 1 ELSE 0 END) as incorrect_preds,\n    AVG(CASE WHEN prediction_correct = true THEN confidence_score ELSE NULL END) as avg_conf_correct,\n    AVG(CASE WHEN prediction_correct = false THEN confidence_score ELSE NULL END) as avg_conf_incorrect,\n    COUNT(CASE WHEN confidence_score >= 60 AND prediction_correct = true THEN 1 END) as high_conf_correct,\n    COUNT(CASE WHEN confidence_score >= 60 THEN 1 END) as high_conf_total,\n    COUNT(CASE WHEN confidence_score >= 50 AND confidence_score < 60 AND prediction_correct = true THEN 1 END) as med_conf_correct,\n    COUNT(CASE WHEN confidence_score >= 50 AND confidence_score < 60 THEN 1 END) as med_conf_total,\n    COUNT(CASE WHEN confidence_score < 50 AND prediction_correct = true THEN 1 END) as low_conf_correct,\n    COUNT(CASE WHEN confidence_score < 50 THEN 1 END) as low_conf_total\n  FROM predictions\n  WHERE actual_winner IS NOT NULL\n),\npinecone_count AS (\n  SELECT COUNT(*) as total FROM matches\n)\nUPDATE system_metadata\nSET\n  days_operated = days_operated + 1,\n  total_matches_processed = (SELECT COUNT(*) FROM matches),\n  total_predictions_made = (SELECT total_preds FROM stats),\n  correct_predictions = (SELECT correct_preds FROM stats),\n  incorrect_predictions = (SELECT incorrect_preds FROM stats),\n  overall_accuracy = ROUND((SELECT correct_preds::numeric / NULLIF(total_preds, 0) * 100 FROM stats), 2),\n  avg_confidence_when_correct = ROUND((SELECT avg_conf_correct FROM stats), 2),\n  avg_confidence_when_incorrect = ROUND((SELECT avg_conf_incorrect FROM stats), 2),\n  accuracy_high_confidence = ROUND((SELECT high_conf_correct::numeric / NULLIF(high_conf_total, 0) * 100 FROM stats), 2),\n  accuracy_medium_confidence = ROUND((SELECT med_conf_correct::numeric / NULLIF(med_conf_total, 0) * 100 FROM stats), 2),\n  accuracy_low_confidence = ROUND((SELECT low_conf_correct::numeric / NULLIF(low_conf_total, 0) * 100 FROM stats), 2),\n  pinecone_record_count = (SELECT total FROM pinecone_count),\n  learning_phase = CASE\n    WHEN days_operated + 1 < 8 THEN 'phase1_data_collection'\n    WHEN days_operated + 1 < 22 THEN 'phase2_pattern_recognition'\n    ELSE 'phase3_mature_system'\n  END,\n  last_update = NOW(),\n  last_result_date = CURRENT_DATE\nWHERE id = 1\nRETURNING days_operated, learning_phase, overall_accuracy, pinecone_record_count;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -960,
        128
      ],
      "id": "8b4f0d61-0511-4372-9cf3-f7b6d9181921",
      "name": "Update System Metadata",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "  INSERT INTO prediction_accuracy (\n    date,\n    total_predictions,\n    correct_predictions,\n    incorrect_predictions,\n    daily_accuracy,\n    high_conf_predictions,\n    high_conf_correct,\n    high_conf_accuracy,\n    medium_conf_predictions,\n    medium_conf_correct,\n    medium_conf_accuracy,\n    low_conf_predictions,\n    low_conf_correct,\n    low_conf_accuracy,\n    learning_phase\n  )\n  VALUES (\n    CURRENT_DATE,\n    {{ $('Calculate Daily Stats').item.json.total_predictions }},\n    {{ $('Calculate Daily Stats').item.json.correct_predictions }},\n    {{ $('Calculate Daily Stats').item.json.incorrect_predictions }},\n    {{ $('Calculate Daily Stats').item.json.accuracy_percentage }},\n    {{ $('Calculate Daily Stats').item.json.high_confidence.total }},\n    {{ $('Calculate Daily Stats').item.json.high_confidence.correct }},\n    {{ $('Calculate Daily Stats').item.json.high_confidence.accuracy }},\n    {{ $('Calculate Daily Stats').item.json.medium_confidence.total }},\n    {{ $('Calculate Daily Stats').item.json.medium_confidence.correct }},\n    {{ $('Calculate Daily Stats').item.json.medium_confidence.accuracy }},\n    {{ $('Calculate Daily Stats').item.json.low_confidence.total }},\n    {{ $('Calculate Daily Stats').item.json.low_confidence.correct }},\n    {{ $('Calculate Daily Stats').item.json.low_confidence.accuracy }},\n    (SELECT learning_phase FROM system_metadata WHERE id = 1)\n  )\n  ON CONFLICT (date) DO UPDATE SET\n    total_predictions = EXCLUDED.total_predictions,\n    correct_predictions = EXCLUDED.correct_predictions,\n    incorrect_predictions = EXCLUDED.incorrect_predictions,\n    daily_accuracy = EXCLUDED.daily_accuracy,\n    high_conf_predictions = EXCLUDED.high_conf_predictions,\n    high_conf_correct = EXCLUDED.high_conf_correct,\n    high_conf_accuracy = EXCLUDED.high_conf_accuracy,\n    medium_conf_predictions = EXCLUDED.medium_conf_predictions,\n    medium_conf_correct = EXCLUDED.medium_conf_correct,\n    medium_conf_accuracy = EXCLUDED.medium_conf_accuracy,\n    low_conf_predictions = EXCLUDED.low_conf_predictions,\n    low_conf_correct = EXCLUDED.low_conf_correct,\n    low_conf_accuracy = EXCLUDED.low_conf_accuracy,\n    learning_phase = EXCLUDED.learning_phase;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -752,
        128
      ],
      "id": "340279c6-a535-40ed-98a3-35721f9f4bd2",
      "name": "Store Daily Stats",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  prediction_id,\n  tournament,\n  surface,\n  player1,\n  player2,\n  predicted_winner,\n  actual_winner,\n  confidence_score,\n  reasoning,\n  odds_player1,\n  odds_player2,\n  days_operated,\n  data_quality_score,\n  player1_data_available,\n  player2_data_available\nFROM predictions\nWHERE prediction_correct = false\n  AND prediction_date = '{{ $('Extract mathces').first().json.match_date }}'\nORDER BY confidence_score DESC;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -544,
        128
      ],
      "id": "13eb6ef7-6828-4631-a28e-6d38c615fe32",
      "name": "Get Failed Predictions",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "openai/gpt-5",
          "mode": "id"
        },
        "messages": {
          "values": [
            {
              "content": "=Analyze today's failed predictions and identify learning opportunities.\n\n  Failed Predictions:\n  {{ JSON.stringify($('Get Failed Predictions').all().map(item => item.json), null, 2) }}\n\n  Daily Stats:\n  {{ JSON.stringify($('Calculate Daily Stats').item.json, null, 2) }}\n\n  Respond with JSON in this exact format:\n  {\n    \"summary\": \"Brief 2-3 sentence summary of today's performance\",\n    \"key_failures\": [\n      {\n        \"prediction_id\": 123,\n        \"failure_reason\": \"Why this prediction failed\",\n        \"learning\": \"What we learned\",\n        \"impact_score\": 8\n      }\n    ],\n    \"patterns_discovered\": [\n      {\n        \"pattern_type\": \"surface_specialist | giant_killer | odds_bias | other\",\n        \"description\": \"Pattern description\",\n        \"affected_predictions\": [123, 456],\n        \"recommendation\": \"How to adjust future predictions\"\n      }\n    ],\n    \"confidence_calibration\": {\n      \"high_confidence_analysis\": \"Analysis of 60%+ confidence predictions\",\n      \"recommended_adjustment\": \"Increase/Decrease confidence by X% for Y scenarios\"\n    },\n    \"action_items\": [\n      \"Specific actionable improvement for future predictions\"\n    ]\n  }\n"
            },
            {
              "content": "You are an expert tennis prediction analyst. Analyze failed predictions to identify patterns, systematic errors, and improvement opportunities. Always respond with valid JSON only.\n",
              "role": "system"
            }
          ]
        },
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        -368,
        128
      ],
      "id": "d7ffe189-9a65-46e7-8611-ded3d6ee08e5",
      "name": "LLM Learning Analysis",
      "executeOnce": true,
      "retryOnFail": true,
      "credentials": {
        "openAiApi": {
          "id": "AQOSCAm1HBdgfCrn",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "  const response = $input.first().json;\n\n  // Extract JSON from OpenAI node response\n  let analysis;\n  try {\n    // OpenAI node returns the message content directly\n    const content = response.message?.content || response.choices?.[0]?.message?.content;\n\n    // Try to parse as JSON\n    analysis = typeof content === 'string' ? JSON.parse(content) : content;\n  } catch (e) {\n    console.error('Failed to parse LLM response:', e);\n    analysis = {\n      summary: 'LLM analysis failed to parse',\n      key_failures: [],\n      patterns_discovered: [],\n      confidence_calibration: {\n        high_confidence_analysis: 'N/A',\n        recommended_adjustment: 'N/A'\n      },\n      action_items: ['Review LLM response format']\n    };\n  }\n\n  return { json: analysis };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        128
      ],
      "id": "5a5cf30a-7d31-4541-af88-b6da0393ace8",
      "name": "Extract LLM Response"
    },
    {
      "parameters": {
        "jsCode": "  const analysis = $input.first().json;\n  const dailyStats = $('Calculate Daily Stats').first().json;\n\n  // Helper function to escape single quotes for SQL\n  function escapeSql(str) {\n    if (!str) return '';\n    return str.toString().replace(/'/g, \"''\");\n  }\n\n  // Build learning log entries from LLM analysis\n  const learningEntries = [];\n\n  // 1. Daily summary entry\n  learningEntries.push({\n    json: {\n      log_type: 'daily_summary',\n      description: escapeSql(analysis.summary),\n      learning_data: JSON.stringify({\n        daily_stats: dailyStats,\n        total_failures: analysis.key_failures.length,\n        patterns_found: analysis.patterns_discovered.length\n      }).replace(/'/g, \"''\"),  // Escape quotes in JSON too\n      impact_score: 5\n    }\n  });\n\n  // 2. Individual failure entries\n  analysis.key_failures.forEach(failure => {\n    learningEntries.push({\n      json: {\n        log_type: 'prediction_failure',\n        description: escapeSql(failure.failure_reason),\n        related_prediction_id: failure.prediction_id,\n        learning_data: JSON.stringify({\n          learning: failure.learning,\n          impact_score: failure.impact_score\n        }).replace(/'/g, \"''\"),\n        impact_score: failure.impact_score || 5\n      }\n    });\n  });\n\n  // 3. Pattern discovery entries\n  analysis.patterns_discovered.forEach(pattern => {\n    learningEntries.push({\n      json: {\n        log_type: 'pattern_discovery',\n        description: escapeSql(pattern.description),\n        learning_data: JSON.stringify({\n          pattern_type: pattern.pattern_type,\n          affected_predictions: pattern.affected_predictions,\n          recommendation: pattern.recommendation\n        }).replace(/'/g, \"''\"),\n        impact_score: 7\n      }\n    });\n  });\n\n  // 4. Confidence calibration entry\n  learningEntries.push({\n    json: {\n      log_type: 'confidence_calibration',\n      description: escapeSql(analysis.confidence_calibration.high_confidence_analysis),\n      learning_data: JSON.stringify({\n        recommended_adjustment: analysis.confidence_calibration.recommended_adjustment,\n        daily_accuracy: dailyStats.accuracy_percentage\n      }).replace(/'/g, \"''\"),\n      impact_score: 6\n    }\n  });\n\n  return learningEntries;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ],
      "id": "398533f4-5b35-48a6-9908-d286caea8a0c",
      "name": "Store Learning Insights"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO learning_log (\n  log_date,\n  learning_type,\n  description,\n  related_prediction_id,\n  learning_data,\n  impact_score,\n  action_taken\n)\nVALUES (\n  CURRENT_DATE,\n  '{{ $json.log_type }}',\n  '{{ $json.description }}',\n  {{ $json.related_prediction_id || 'NULL' }},\n  '{{ $json.learning_data }}'::jsonb,\n  {{ $json.impact_score }},\n  'stored_for_analysis'\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        976,
        144
      ],
      "id": "575820f3-a51a-4e72-9ba1-56d9bc76b792",
      "name": "Insert Learning Logs",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "  // Get prediction data from Update Prediction (2 nodes back)\n  const predictionData = $('Update Prediction').item.json;\n\n  // Just pass it through\n  return { json: predictionData };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1392,
        288
      ],
      "id": "c4b155b1-fb40-42e9-a4d6-bf50c0e04e3b",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE matches m\nSET prediction_id = p.prediction_id\nFROM predictions p\nWHERE m.player1 = p.player1\n  AND m.player2 = p.player2\n  AND m.tournament = p.tournament\n  AND m.match_date = CURRENT_DATE\n  AND m.prediction_id IS NULL\nRETURNING m.match_unique_id, m.prediction_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1584,
        288
      ],
      "id": "ce170bb3-d370-4d52-9040-903447032fab",
      "name": "Link Match to Prediction",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const analysis = $('Extract LLM Response').first().json;\nconst failedPredictions = $('Get Failed Predictions').all();\n\n// Helper function to escape single quotes for SQL\nfunction escapeSql(str) {\n  if (!str) return '';\n  return str.toString().replace(/'/g, \"''\");\n}\n\n// Helper function to determine insight type from description\nfunction getInsightType(description) {\n  const desc = description.toLowerCase();\n  if (desc.includes('surface') && (desc.includes('specialist') || desc.includes('better'))) {\n    return 'surface_specialist';\n  }\n  if (desc.includes('upset') || desc.includes('underdog') || desc.includes('giant killer')) {\n    return 'giant_killer';\n  }\n  if (desc.includes('form') || desc.includes('momentum')) {\n    return 'momentum_rising';\n  }\n  if (desc.includes('odds') && (desc.includes('undervalued') || desc.includes('overrated'))) {\n    return 'odds_undervalued';\n  }\n  return 'other';\n}\n\n// Fixed player insights extraction\nconst playerInsights = [];\n\nif (analysis.patterns_discovered && analysis.patterns_discovered.length > 0) {\n  analysis.patterns_discovered.forEach(pattern => {\n    const description = pattern.description || '';\n    const insightType = getInsightType(description);\n    const confidence = Math.min(90, Math.max(60, (pattern.impact_score || 5) * 10));\n    const discoveredDate = new Date().toISOString().split('T')[0];\n\n    // Method 1: Direct player name matching from failed predictions\n    failedPredictions.forEach(pred => {\n      const player1 = pred.json.player1 || '';\n      const player2 = pred.json.player2 || '';\n      const actualWinner = pred.json.actual_winner || '';\n      const predictedWinner = pred.json.predicted_winner || '';\n\n      // Check if players are mentioned in the pattern description\n      if (description.includes(player1)) {\n        playerInsights.push({\n          json: {\n            player_name: escapeSql(player1),\n            insight_type: insightType,\n            insight_description: escapeSql(description),\n            confidence: confidence,\n            supporting_data: JSON.stringify(pattern).replace(/'/g, \"''\"),\n            discovered_date: discoveredDate\n          }\n        });\n      }\n\n      if (description.includes(player2)) {\n        playerInsights.push({\n          json: {\n            player_name: escapeSql(player2),\n            insight_type: insightType,\n            insight_description: escapeSql(description),\n            confidence: confidence,\n            supporting_data: JSON.stringify(pattern).replace(/'/g, \"''\"),\n            discovered_date: discoveredDate\n          }\n        });\n      }\n\n      // Method 2: Pattern-based insights (for general patterns)\n      if (insightType === 'giant_killer' && actualWinner !== predictedWinner) {\n        const actualIsUnderdog = (\n          (actualWinner === player1 && parseFloat(pred.json.odds_player1) > parseFloat(pred.json.odds_player2)) ||\n          (actualWinner === player2 && parseFloat(pred.json.odds_player2) > parseFloat(pred.json.odds_player1))\n        );\n\n        if (actualIsUnderdog) {\n          playerInsights.push({\n            json: {\n              player_name: escapeSql(actualWinner),\n              insight_type: insightType,\n              insight_description: escapeSql(`${actualWinner} showed giant killer ability by beating expected favorite`),\n              confidence: confidence,\n              supporting_data: JSON.stringify({ \n                prediction_id: pred.json.prediction_id,\n                pattern_data: pattern \n              }).replace(/'/g, \"''\"),\n              discovered_date: discoveredDate\n            }\n          });\n        }\n      }\n    });\n\n    // Method 3: Surface specialist patterns\n    if (insightType === 'surface_specialist') {\n      failedPredictions.forEach(pred => {\n        const surface = pred.json.surface || '';\n        if (description.toLowerCase().includes(surface.toLowerCase()) && pred.json.actual_winner) {\n          playerInsights.push({\n            json: {\n              player_name: escapeSql(pred.json.actual_winner),\n              insight_type: insightType,\n              insight_description: escapeSql(`${pred.json.actual_winner} shows ${surface} specialist qualities`),\n              confidence: confidence,\n              supporting_data: JSON.stringify({ \n                surface: surface,\n                pattern_data: pattern \n              }).replace(/'/g, \"''\"),\n              discovered_date: discoveredDate\n            }\n          });\n        }\n      });\n    }\n  });\n}\n\n// Return insights or skip marker if none found\nreturn playerInsights.length > 0 ? playerInsights : [{ json: { skip: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        208
      ],
      "id": "6e067639-967f-4d89-9d7f-fadc46815211",
      "name": "Extract Player Insights"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "34f29d74-788e-4ea7-a15c-a6dcda524f44",
              "leftValue": "={{ $json.insight_type }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        480,
        208
      ],
      "id": "749c4ea9-cd58-4b4d-92de-5d6e1e7313ab",
      "name": "If"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Fixed player insights insertion with proper player matching\nINSERT INTO player_insights (\n  player_name,\n  insight_type,\n  insight_description,\n  confidence,\n  supporting_data,\n  discovered_date,\n  is_active\n)\nVALUES (\n  '{{ $json.player_name }}',\n  '{{ $json.insight_type }}',\n  '{{ $json.insight_description }}',\n  {{ $json.confidence }},\n  '{{ $json.supporting_data }}'::jsonb,\n  '{{ $json.discovered_date }}',\n  true\n)\nON CONFLICT (player_name, insight_type, discovered_date) DO NOTHING;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        784,
        368
      ],
      "id": "4c718d31-85f8-461d-90e6-b7cc6e005592",
      "name": "Store Player Insights",
      "credentials": {
        "postgres": {
          "id": "DdZZnEL2dpMFGOf4",
          "name": "Postgres account tennis"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0340f9f4-1e65-4cd1-9de5-8f6c962a40fb",
              "leftValue": "={{ $json.prediction_id }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2384,
        288
      ],
      "id": "467795e3-97a5-4935-97e3-f6e7d25b763d",
      "name": "If1"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract mathces",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract mathces": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Build All Pinecone Records",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Find Matching Prediction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Matching Prediction": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Prediction": {
      "main": [
        [
          {
            "node": "Insert Match Into Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Daily Stats": {
      "main": [
        [
          {
            "node": "Update System Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Telegram Message": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Pinecone Batch": {
      "main": [
        [
          {
            "node": "Upload to Pinecone",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Pinecone": {
      "main": [
        [
          {
            "node": "Calculate Daily Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build All Pinecone Records": {
      "main": [
        [
          {
            "node": "Prepare Pinecone Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Match Into Database": {
      "main": [
        [
          {
            "node": "Link Match to Prediction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update System Metadata": {
      "main": [
        [
          {
            "node": "Store Daily Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Daily Stats": {
      "main": [
        [
          {
            "node": "Get Failed Predictions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Failed Predictions": {
      "main": [
        [
          {
            "node": "LLM Learning Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Learning Analysis": {
      "main": [
        [
          {
            "node": "Extract LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract LLM Response": {
      "main": [
        [
          {
            "node": "Store Learning Insights",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Player Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Learning Insights": {
      "main": [
        [
          {
            "node": "Insert Learning Logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Learning Logs": {
      "main": [
        [
          {
            "node": "Format Telegram Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Link Match to Prediction": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Player Insights": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Store Player Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Update Prediction",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "259a0e8d-523b-403a-a535-a737a969257c",
  "meta": {
    "instanceId": "e21fad19251403203d155894245f670dd6b8cb9831b12c4f346c2d448af3502a"
  },
  "id": "N7Ex1EiCXMEjQmKo",
  "tags": []
}